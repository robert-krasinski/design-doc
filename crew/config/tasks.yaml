prioritize_review_fixes:
  description: |-
    Review the current run folder’s prior QA artifacts and produce a strict JSON prioritization plan for this run. The goal is convergence across reruns: focus on only 2 high-impact QA headings per run, defer the rest, and reduce churn.

    Mandatory first steps (use tools):
    1. Call `list_dir("{output_dir}/inputs")` to confirm available run-scoped inputs.
    2. Call `read_file("{output_dir}/inputs/previous_review_report.json")`.
    3. Optionally call `read_file("{output_dir}/inputs/previous_design_doc.md")` if present.
    4. Base `source_review_found` and `source_review_valid` on the content read from `{output_dir}/inputs/previous_review_report.json`.

    Input expectations:
    - Previous QA report schema is expected to be JSON with `status` and `issues` array.
    - Each issue may include `section`, `issue`, and `fix`.
    - Use exact `issues[].section` values as candidate headings. Do not rename headings.
    - The prior QA report's own `status` value may be `FAIL` and is still valid input for prioritization.
    - Treat the prior review as valid when `read_file("{output_dir}/inputs/previous_review_report.json")` returns parseable JSON with an `issues` array.

    Selection rules (strict):
    - De-duplicate candidate headings while preserving first occurrence order.
    - Treat non-document/meta sections (for example `Inputs` or file paths) as non-actionable and do not select them as headings.
    - Rank headings using this priority order first, then preserve report order for unknown headings:
      - Problem Statement
      - Goals
      - Non-Goals
      - Context & Constraints
      - Architecture Overview
      - Data Design
      - API / Interface Contracts
      - Non-Functional Requirements
      - Risks & Mitigations
      - Rollout Plan
      - Test Strategy
      - Decision Log
      - Prior QA Report Review
      - Assumptions
    - Select exactly 2 headings when 2 or more unique actionable headings exist.
    - If fewer than 2 unique actionable headings exist, select all available headings and do not invent more.
    - If `inputs/previous_review_report.json` is missing, empty, or invalid JSON, emit a baseline fallback plan with no selected headings and status `baseline_no_prior_review`.
    - If the file exists and parses as JSON, do not emit `baseline_no_prior_review` even if the QA report `status` is `FAIL`.
    - If the file parses and contains an `issues` array but zero actionable headings after filtering, return `status: "prioritized"` with `selected_headings: []` and explain that no actionable headings were found.

    Field consistency rules (strict):
    - `source_review_valid: false` is allowed only when the prior review file is missing, empty, or unparseable JSON.
    - If the prior review file parses as JSON with an `issues` array, set `source_review_found: true` and `source_review_valid: true`.
    - If `source_review_valid` is `true`, set `status` to `prioritized`.
    - If `status` is `baseline_no_prior_review`, set `source_review_valid` to `false`.
    - Before writing output, verify `source_review_found`, `source_review_valid`, `status`, and `selected_headings` are consistent with these rules.

    Example (rerun with valid prior QA report whose status is FAIL):
    - Prior input JSON:
      `{{"status":"FAIL","issues":[{{"section":"Context & Constraints","issue":"Missing required section","fix":"Add section"}},{{"section":"Rollout Plan","issue":"Missing required section","fix":"Add section"}}]}}`
    - Valid output must set `source_review_found: true`, `source_review_valid: true`, `status: "prioritized"`, and select the two headings above.

    Output format (strict JSON only, no Markdown):
    - `source_review_found`: boolean
    - `source_review_valid`: boolean
    - `status`: `prioritized` or `baseline_no_prior_review`
    - `selected_headings`: array of strings (exact QA heading names)
    - `deferred_headings`: array of strings
    - `rationale`: array of short strings explaining why selected headings were prioritized
    - `related_change_rule`: string set to: "Non-priority sections may be changed only when directly required by selected priority fixes or consistency with current inputs."
    - `notes`: array of strings
    - Return raw JSON only (no Markdown, no code fences, no backticks).
  expected_output: "JSON prioritization plan with selected_headings/deferred_headings."
  output_file: "{output_dir}/priority_plan.json"

requirements:
  description: |-
    Read inputs from the current run folder’s `inputs/` directory (the same run folder where outputs are written), e.g., `outputs/YYYY-MM-DD/run_*/inputs/context.md` and `outputs/YYYY-MM-DD/run_*/inputs/constraints.yaml`. Also read `outputs/YYYY-MM-DD/run_*/inputs/previous_design_doc.md` and `outputs/YYYY-MM-DD/run_*/inputs/previous_review_report.json` from the current run folder if present. Read `{output_dir}/priority_plan.json` if present and use it to constrain edits. Produce a Markdown section following the strict template below. Use short paragraphs (2–4 sentences) and bullets for lists. If any details are not grounded in inputs, put them under Assumptions.

    Priority behavior (strict):
    - This task owns headings: `Problem Statement`, `Goals`, `Non-Goals`, and this section file’s `Assumptions`.
    - If `{output_dir}/priority_plan.json` selects any owned headings, prioritize fixing those first.
    - If no owned headings are selected, preserve prior content from `inputs/previous_design_doc.md` where possible and avoid substantive changes unless directly required by selected priorities or current inputs.
    - Do not delete previously present required headings owned by this task.
    - Non-priority changes are allowed only when directly related to selected priority fixes or consistency with current inputs.

    Template:
    ## Problem Statement
    - 1–3 bullets describing the user problem and scope
    ## Goals
    - Bullets; include measurable success metrics if present
    ## Non-Goals
    - Bullets; include out-of-scope examples if present
    ## Assumptions
    - Bullets; anything not in inputs
  expected_output: "Markdown with headings: Problem Statement, Goals, Non-Goals, Assumptions."
  output_file: "{output_dir}/sections/requirements.md"

architecture:
  description: |-
    Using the inputs, draft an Architecture Overview with components, boundaries, and a Mermaid diagram (C4-ish L1/L2). Read `{output_dir}/priority_plan.json` if present and use it to constrain edits. Use the strict template below. Use short paragraphs (2–4 sentences) and bullets for lists. If any details are not grounded in inputs, put them under Assumptions.

    Priority behavior (strict):
    - This task owns headings: `Architecture Overview`, `Components`, `Trade-offs`, `Diagram`, and this section file’s `Assumptions`.
    - If `{output_dir}/priority_plan.json` selects `Architecture Overview`, prioritize architecture fixes first.
    - If no owned headings are selected, preserve prior content from `inputs/previous_design_doc.md` where possible and avoid substantive changes unless directly required by selected priorities or current inputs.
    - Do not delete previously present required headings owned by this task.
    - Non-priority changes are allowed only when directly related to selected priority fixes or consistency with current inputs.

    Template:
    ## Architecture Overview
    - 1–2 short paragraphs
    ## Components
    | Component | Responsibility | Interfaces |
    | --- | --- | --- |
    | ... | ... | ... |
    ## Trade-offs
    - 2–3 bullets
    ## Diagram
    ```mermaid
    flowchart LR
      A[Client] --> B[Service]
    ```
    ## Assumptions
    - Bullets
  expected_output: "Markdown with headings: Architecture Overview, Components, Trade-offs, Diagram."
  output_file: "{output_dir}/sections/architecture.md"

data_api:
  description: |-
    Draft Data Design and API/Interface Contracts. Provide entities, flows, storage/retention, and an API table or a minimal OpenAPI-like snippet. Read `{output_dir}/priority_plan.json` if present and use it to constrain edits. Use the strict template below. Use short paragraphs (2–4 sentences) and bullets for lists. If any details are not grounded in inputs, put them under Assumptions.

    Priority behavior (strict):
    - This task owns headings: `Data Design`, `Entities`, `Data Flows`, `Storage/Retention`, `API / Interface Contracts`, and this section file’s `Assumptions`.
    - If `{output_dir}/priority_plan.json` selects `Data Design` or `API / Interface Contracts`, prioritize those fixes first.
    - If no owned headings are selected, preserve prior content from `inputs/previous_design_doc.md` where possible and avoid substantive changes unless directly required by selected priorities or current inputs.
    - Do not delete previously present required headings owned by this task.
    - Non-priority changes are allowed only when directly related to selected priority fixes or consistency with current inputs.

    Template:
    ## Data Design
    - 1–2 short paragraphs
    ## Entities
    | Entity | Key Fields | Source | Retention |
    | --- | --- | --- | --- |
    | ... | ... | ... | ... |
    ## Data Flows
    - Bullets
    ## Storage/Retention
    - Bullets
    ## API / Interface Contracts
    | Endpoint | Method | Request | Response | Errors |
    | --- | --- | --- | --- | --- |
    | ... | ... | ... | ... | ... |
    ## Assumptions
    - Bullets
  expected_output: "Markdown with headings: Data Design, Entities, Data Flows, Storage/Retention, API / Interface Contracts."
  output_file: "{output_dir}/sections/data_api.md"

security:
  description: |-
    Perform a security/compliance review: threats, risks, mitigations. Reference constraints if available. Read `{output_dir}/priority_plan.json` if present and use it to constrain edits. Use the strict template below. Use short paragraphs (2–4 sentences) and bullets for lists. If any details are not grounded in inputs, put them under Assumptions.

    Priority behavior (strict):
    - This task owns headings: `Risks & Mitigations`, `Security Controls`, and this section file’s `Assumptions`.
    - If `{output_dir}/priority_plan.json` selects `Risks & Mitigations`, prioritize those fixes first.
    - If no owned headings are selected, preserve prior content from `inputs/previous_design_doc.md` where possible and avoid substantive changes unless directly required by selected priorities or current inputs.
    - Do not delete previously present required headings owned by this task.
    - Non-priority changes are allowed only when directly related to selected priority fixes or consistency with current inputs.

    Template:
    ## Risks & Mitigations
    | Threat | Impact | Likelihood | Mitigation |
    | --- | --- | --- | --- |
    | ... | ... | ... | ... |
    ## Security Controls
    - Bullets
    ## Assumptions
    - Bullets
  expected_output: "Markdown with headings: Risks & Mitigations, Security Controls."
  output_file: "{output_dir}/sections/security.md"

sre:
  description: |-
    Define Non-Functional Requirements and Ops Plan: SLIs/SLOs, logging, alerting, runbooks. Read `{output_dir}/priority_plan.json` if present and use it to constrain edits. Use the strict template below. Use short paragraphs (2–4 sentences) and bullets for lists. If any details are not grounded in inputs, put them under Assumptions.

    Priority behavior (strict):
    - This task owns headings: `Non-Functional Requirements`, `Observability`, `Ops Runbooks`, and this section file’s `Assumptions`.
    - If `{output_dir}/priority_plan.json` selects `Non-Functional Requirements`, prioritize those fixes first.
    - If no owned headings are selected, preserve prior content from `inputs/previous_design_doc.md` where possible and avoid substantive changes unless directly required by selected priorities or current inputs.
    - Do not delete previously present required headings owned by this task.
    - Non-priority changes are allowed only when directly related to selected priority fixes or consistency with current inputs.

    Template:
    ## Non-Functional Requirements
    | Metric | Target | Notes |
    | --- | --- | --- |
    | ... | ... | ... |
    ## Observability
    - Logging: bullets
    - Metrics: bullets
    - Alerts: bullets with thresholds
    ## Ops Runbooks
    - Bullets
    ## Assumptions
    - Bullets
  expected_output: "Markdown with headings: Non-Functional Requirements, Observability, Ops Runbooks."
  output_file: "{output_dir}/sections/nfrs_ops.md"

integrate:
  description: |-
    Read all files in `{output_dir}/sections/` and integrate them into a single design doc. This is a merge task first, not a meta/status report task. Read `{output_dir}/priority_plan.json` if present and use it to prioritize which parts are refined this run, but do not omit non-priority section content. Use `templates/design_doc.md` as the base structure. Ensure consistent terminology. Use short paragraphs (2–4 sentences) and bullets for lists. If any details are not grounded in inputs, put them under the single top-level Assumptions section. Add a final "Consistency Checklist" section with bullets: terminology consistency, API naming, component naming.

    Integration procedure (strict, follow in order):
    1. Read every file in `{output_dir}/sections/`.
    2. Extract the content under each heading from those section files.
    3. Build the final document using `templates/design_doc.md` headings as the target structure.
    4. For each template heading with source content in a section file, copy or condense that source content into the matching final heading.
    5. Only after core sections are populated, add/finalize integrator-owned sections: `Context & Constraints`, `Rollout Plan`, `Test Strategy`, `Decision Log`, `Prior QA Report Review`, `Consistency Checklist`, and the single top-level `Assumptions`.

    Section mapping (strict):
    - `Problem Statement`, `Goals`, `Non-Goals` <- `{output_dir}/sections/requirements.md`
    - `Architecture Overview` <- `{output_dir}/sections/architecture.md`
    - `Data Design`, `API / Interface Contracts` <- `{output_dir}/sections/data_api.md`
    - `Non-Functional Requirements` <- `{output_dir}/sections/nfrs_ops.md`
    - `Risks & Mitigations` <- `{output_dir}/sections/security.md`
    - Summarize supporting headings into the corresponding template sections instead of discarding them, including: `Components`, `Trade-offs`, `Diagram`, `Entities`, `Data Flows`, `Storage/Retention`, `Security Controls`, `Observability`, and `Ops Runbooks`.

    Priority behavior (strict):
    - Integrator owns/finalizes headings: `Context & Constraints`, `Rollout Plan`, `Test Strategy`, `Decision Log`, `Prior QA Report Review`, top-level `Assumptions`, and `Consistency Checklist`.
    - Priority selection controls what is refined first this run; it does not allow omission of existing section content from the final integrated document.
    - If priority headings are not owned by the integrator, preserve previously present non-priority sections from `inputs/previous_design_doc.md` where possible and avoid unrelated rewrites.
    - Missing non-priority content in current section files should be reconstructed from `inputs/previous_design_doc.md` when possible instead of being omitted.
    - Non-priority sections may receive minimal edits, but they must still appear in the final document and retain source/previous content.
    - Non-priority changes are allowed only when directly related to selected priority fixes or consistency with current inputs.

    Do not do the following (strict):
    - Do not output a document that only contains meta/integrator sections while omitting available content from `{output_dir}/sections/*.md`.
    - Do not remove a template section if source content exists for it in any section file.
    - Do not replace core section summaries with status text about missing `priority_plan.json` or missing prior review.
    - Do not duplicate top-level `## Assumptions`; produce exactly one top-level `## Assumptions` section in the final document.

    Summarization rules:
    - Summarize section-file content into the final document, preserving concrete facts, tables, and key bullets when needed.
    - If a section file already contains a required heading, prefer its content over inventing new text.
    - Merge assumptions from section files and integrator notes into one concise top-level `## Assumptions` section.

    Final self-check before returning (mandatory):
    - Confirm the final doc includes all headings from `templates/design_doc.md`.
    - Confirm content from each available file in `{output_dir}/sections/` is represented in the final doc.
    - Confirm exactly one top-level `## Assumptions` section.
    - Confirm `## Prior QA Report Review` is present.
    - Confirm no core section is replaced only by meta/status text when source content exists.

    Add a strict section:
    ## Prior QA Report Review
    - State whether the previous QA report (`outputs/YYYY-MM-DD/run_*/inputs/previous_review_report.json`) from the current run folder was reviewed.
    - State whether `{output_dir}/priority_plan.json` was reviewed.
    - List the selected priority headings from `{output_dir}/priority_plan.json` (or "No selected priorities" in baseline mode).
    - List at least 2 specific issues addressed (or "No actionable issues" if none).
    - List deferred headings (or "None").
  expected_output: "Complete design doc in Markdown."
  output_file: "{output_dir}/design_doc.md"
